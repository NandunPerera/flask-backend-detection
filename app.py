# -*- coding: utf-8 -*-
"""Copy of Copy of flask-age-gender

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ue6eCwuPURJBaum-wOJu6JOO1Jnhp2p0
"""





"""# Data Paths"""

# dir_ = '/content/drive/MyDrive/flask/models/'
# gender = dir_ +  'model_gender.h5'
# age_v2 = dir_ +  'model_age_v2.h5'
# age_v1 = dir_ +  'age_mode_vN.h5'

YOUR_APP_NAME = "g10-age-gender"
url_gen = f'https://{YOUR_APP_NAME}.herokuapp.com/v1/models/gender:predict'
url_age = f'https://{YOUR_APP_NAME}.herokuapp.com/v1/models/age:predict'

# INDEX_PATH = '/content/drive/MyDrive/flask/'

"""# App Code"""

import sys
import os
import numpy as np

from tensorflow import keras
from tensorflow.keras.models import load_model

from flask import Flask, redirect, url_for, request, render_template
from flask_ngrok import run_with_ngrok

# Imports
import dlib
from PIL import Image
from skimage import io
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
import numpy as np
import tensorflow as tf

import requests
import json

def detect_faces(image):
    # Create a face detector
    face_detector = dlib.get_frontal_face_detector()

    # Run detector and get bounding boxes of the faces on image.
    detected_faces = face_detector(image, 1)
    face_frames = [(x.left(), x.top(), x.right(), x.bottom()) for x in
                   detected_faces]

    return face_frames

def make_prediction(instances, many=False,isAge = False):
    if not many:
        data = json.dumps({"signature_name": "serving_default", "instances": [instances.tolist()]})
    else:
        data = json.dumps({"signature_name": "serving_default", "instances": instances.tolist()})
    headers = {"content-type": "application/json"}
    if(not isAge):
      json_response = requests.post(url_gen, data=data, headers=headers)
    else:
      json_response = requests.post(url_age, data=data, headers=headers)
    jj = json.loads(json_response.text)
    return jj

"""# External Predict"""

# def model_predict_serving(img_path):
#     test_image = io.imread(img_path)
#     detected_faces = detect_faces(test_image)

#     classes = [ 'Male' , 'Female' ]

#     for n, face_rect in enumerate(detected_faces):
#         face = Image.fromarray(test_image).crop(face_rect)
#         face_array = tf.keras.preprocessing.image.img_to_array(face)
#         face_img = tf.keras.preprocessing.image.array_to_img(face_array)

#         dim_age = (200, 200)
#         dim_gender = (128, 128)
#         resized_age_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_age) / 255
#         resized_gender_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_gender) / 255

#         p_gender =  make_prediction(np.expand_dims( resized_gender_arr , 0 ),many = True)
#         p_age = make_prediction(np.expand_dims( resized_age_arr , 0 ),many = True, isAge= True)

#         gender = classes[np.argmax(p_gender['predictions'][0])]
#         age = round((p_age['predictions'][0])[0] * 116)
#         print(age,gender)
        
#         face_img = tf.keras.preprocessing.image.array_to_img(resized_age_arr)

#         return f'Gender: {gender} | Age: {age}'



"""# Image preprocessing nandun"""

# def loadImage(filepath):
#   test_img = image.load_img(filepath, target_size=(200, 200))
#   test_img = image.img_to_array(test_img)
#   test_img = np.expand_dims(test_img, axis = 0)
#   test_img /= 255
#   return test_img

"""# Local Predict"""



from fer import FER

emotion_detector = FER(mtcnn=True)



# pip install deepface

# from deepface import DeepFace

def predict_emotion(img_path):
    # face_analysis = DeepFace.analyze(img_path)

    test_img = io.imread(img_path)

    dominant_emotion, emotion_score = emotion_detector.top_emotion(test_img)
    
    return dominant_emotion


    # return f'emotion{face_analysis["dominant_emotion"]}| age:{face_analysis["age"]}'

# def model_predict(img_path):
#     test_image = io.imread(img_path)
#     detected_faces = detect_faces(test_image)

#     classes = [ 'Male' , 'Female' ]

#     for n, face_rect in enumerate(detected_faces):
#         face = Image.fromarray(test_image).crop(face_rect)
#         face_array = tf.keras.preprocessing.image.img_to_array(face)
#         face_img = tf.keras.preprocessing.image.array_to_img(face_array)

#         dim_age = (200, 200)
#         dim_gender = (128, 128)
#         resized_age_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_age) / 255
#         resized_gender_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_gender) / 255

#         pred_gen = model_gender.predict( np.expand_dims( resized_gender_arr , 0 ) )[0]
#         pred_age_v1 = int(model_age_v1.predict(loadImage(img_path) )*116)
#         pred_age_v2 = model_age_v2.predict( np.expand_dims( resized_age_arr , 0 ) )

#         print(pred_age_v2[0] * 116 , pred_age_v2[1] * 116)
        
#         label_g = classes[ np.argmax( pred_gen ) ]
#        # label_a_v1 = round(pred_age_v1[0].tolist()[0] * 116)
#         label_a_v1 = pred_age_v1
#         label_a_v2 = round((((pred_age_v2[0] * 116 + pred_age_v2[1] * 116)/2)[0]).tolist()[0])
#         face_img = tf.keras.preprocessing.image.array_to_img(resized_age_arr)
#         label_emotion = predict_emotion(img_path)



#         return f'Gender: {label_g} | Age(V1): {label_a_v1} | Age(V2): {label_a_v2} | emotion: {label_emotion}'

"""# External with Alignments"""

predictor_path = 'flask/shape_predictor_68_face_landmarks.dat'

def model_predict_serving_align(img_path):
    classes = [ 'Male' , 'Female' ]

    results = []

    detector = dlib.get_frontal_face_detector()
    sp = dlib.shape_predictor(predictor_path)

    test_img = io.imread(img_path)
    dets = detector(test_img, 1)

    num_faces = len(dets)
    if num_faces == 0:
      return "Sorry, there were no faces found"
      
    
    #detected_faces = detect_faces(test_image)

    faces = dlib.full_object_detections()
    for detection in dets:
        faces.append(sp(test_img, detection))
    

    images = dlib.get_face_chips(test_img, faces,size = 200,padding = 0.25 )

    for face in images:
        plt.subplot(1, len(images), n+1)
        plt.axis('off')
        plt.imshow(face)

        face_array = tf.keras.preprocessing.image.img_to_array(face)
        face_img = tf.keras.preprocessing.image.array_to_img(face_array)

        dim_age = (200, 200)
        dim_gender = (128, 128)
        resized_age_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_age) / 255
        resized_gender_arr = tf.keras.preprocessing.image.smart_resize(face_array,size=dim_gender) / 255

        p_gender =  make_prediction(np.expand_dims( resized_gender_arr , 0 ),many = True)
        p_age = make_prediction(np.expand_dims( resized_age_arr , 0 ),many = True, isAge= True)

        gender = classes[np.argmax(p_gender['predictions'][0])]
        age = round((p_age['predictions'][0])[0] * 116)
        label_emotion = predict_emotion(img_path)
        print(age,gender)
        
        face_img = tf.keras.preprocessing.image.array_to_img(resized_age_arr)

        return f'Gender: {gender}|Age: {age}|emotion:{label_emotion}'

"""# Flask Code"""

# Load your trained model
# model_gender = keras.models.load_model(gender)
# model_age_v1 = keras.models.load_model(age_v1)
# model_age_v2 = keras.models.load_model(age_v2)

#Template Folder Path
TEMPLATE_PATH = '/template'
STATIC_PATH = '/static'

# Define a flask app
app = Flask(__name__,template_folder=TEMPLATE_PATH,static_folder=STATIC_PATH)
# run_with_ngrok(app)  # Start ngrok when app is run

# !pip install pyngrok==4.1.1

# !wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.tgz

# !tar -xvf /content/ngrok-stable-linux-amd64.tgz

# !./ngrok authtoken 28mYPYUE6RZ4JilKi7A0wUqIlHU_7B3KXBbRG5xBBCGq8zdnj

# @app.route('/', methods=['GET'])
# def index():
#     # Main page
#     return render_template('index.html')

@app.route('/predict', methods=['GET', 'POST'])
def upload():
    if request.method == 'POST':
        # Get the file from post request
        f = request.files['file']
        print(f.filename)
        # Save the file to ./uploads
        basepath = '/content'
        file_path = os.path.join(
            basepath, 'sample_data', f.filename)
        f.save(file_path)
        print(file_path)
        # Make prediction | Involves Model
        # predictions = model_predict(file_path) #Predict Locally
        predictions = model_predict_serving_align(file_path) #Predict with TFServing
        print(predictions)

        return predictions 

    return None


if __name__ == '__main__':
    app.run()

